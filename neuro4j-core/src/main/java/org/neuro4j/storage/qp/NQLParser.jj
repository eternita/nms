options{  STATIC = false;}PARSER_BEGIN(NQLParser)package org.neuro4j.storage.qp;import java.lang.StringBuffer;import java.io.StringReader;import java.io.Reader;import org.neuro4j.core.Network;import org.neuro4j.core.Entity;import org.neuro4j.core.Path;import java.util.Map;import java.util.HashMap;import java.util.Set;import java.util.HashSet;import org.neuro4j.storage.StorageException;import org.neuro4j.storage.qp.NQLProcessor;public class NQLParser{  private NQLProcessor nqlProcessor;  private String query;    public NQLParser(String s, NQLProcessor nqlProcessor)  {    this ((Reader) (new StringReader(s)));    this.nqlProcessor = nqlProcessor;    this.query = s;  }}PARSER_END(NQLParser)/** 
 *  Top level
 */Network parse() throws StorageException :{}{  (    command()  )  (    < PIPE >//    First cycle is used for reading parameters from the query (e.g. LIMIT) which are at the end but used in the middle.//    So, we should not move networks through pipes now//    {//      nqlProcessor.startNewCommand();//    }    command()  )*  < EOF >  {  ReInit((Reader) (new StringReader(this.query)));  nqlProcessor.setParseCycle(nqlProcessor.SECOND_CYCLE);  }    (    command()  )  (    < PIPE >    {      nqlProcessor.startNewCommand();    }    command()  )*  < EOF >    {    return nqlProcessor.getNetwork();  }}void command() throws StorageException :{//  System.out.println(" command ");}{  (    < SELECT > select()  | < INSERT > insert()  | < UPDATE > update()  | < DELETE > delete()  | < BEHAVE > behave()  | < SQL > sql()  )  {    return;  }}void insert() throws StorageException :{//  System.out.println(" insert ");  String ertype = "";  Map<String, String> params = new HashMap<String, String>();}{    (      < E_LBRACE >      {        ertype = "entity";      }    |      < R_LBRACE >      {        ertype = "relation";      }    )        getParams(params)    < RPAREN >  {    nqlProcessor.insert(ertype, params);    return;  }}void update() throws StorageException :{//  System.out.println(" update ");  String ertype = "";  Map<String, String> setProperties = new HashMap<String, String>();  Set<String> removeProperties = new HashSet<String>();  Network updateNet = null;  Network addConnections = null;  Network removeConnections = null;}{//    (//      < E_LBRACE >//      {//        ertype = "entity";//      }//    |//      < R_LBRACE >//      {//        ertype = "relation";//      }//    ) //       getParams(setProperties)//    < RPAREN >    (        < SET_PROPERTY >        (          getParams(setProperties)        ) ?        (          {            nqlProcessor.reset();          }	      parseER()	      {	        addConnections = nqlProcessor.finishERParse();	      }        ) ?            )?    (        < REMOVE_PROPERTY >        (          getList(removeProperties)        ) ?        (          {            nqlProcessor.reset();          }          parseER()          {            removeConnections = nqlProcessor.finishERParse();          }        ) ?    )?    < WHERE >    (	  {	    nqlProcessor.reset();	  }      parseER()      {        updateNet = nqlProcessor.finishERParse();      }    )  {    nqlProcessor.update(updateNet, setProperties, removeProperties, addConnections, removeConnections);// update(ertype, params);    return;  }}void behave() throws StorageException :{//  System.out.println(" behave ");  Token tFlow, tComparator, tValue;  String flow = "";  String processor = "";  Map<String, String> params = new HashMap<String, String>();}{    < LPAREN >        getParams(params)    < RPAREN >  {    nqlProcessor.behave(params);    return;  }}void sql() throws StorageException :{//  System.out.println(" sql ");  Token tFlow, tComparator, tValue;  String flow = "";  String processor = "";  Map<String, String> params = new HashMap<String, String>();//  params.put("q", "select * from net_table");}{  < LPAREN >  (    getParams(params)  )?  < RPAREN >  {    nqlProcessor.sql(params);    return;  }}/** * Reads parameters String like following:   a='b' c="d" * Parameter's name and value are case sensitive (because block parameters are case sensitive) */void getParams(Map<String, String> params) :{//  System.out.println(" getParams() ");  Token tKey, tValue;}{  (    (      tKey = < STRING > |      tKey = < LIMIT >    )  )  < EQUALS >  (    tValue = < QUOTED_STRING >  )  {    String key = tKey.image;    String value = tValue.image.substring(1, tValue.image.length() - 1);    params.put(key, value);  }  (    getParams(params)  ) ?  {    return;  }}void getList(Set<String> params) :{  Token tKey;}{  (    (      tKey = < STRING > |      tKey = < LIMIT >    )  )  {    String key = tKey.image;    params.add(key);  }  (    getList(params)  ) ?  {    return;  }}void getParams4recursion(Map<String, String> params) throws StorageException :{  Token tKey, tValue;}{ (  (       recursionIgnore()   )  |  (       recursionUseOnly()   )  |  (      (        (          tKey = < STRING > |          tKey = < LIMIT >        )      )      < EQUALS >      (        tValue = < QUOTED_STRING >      )      {        String key = tKey.image;        String value = tValue.image.substring(1, tValue.image.length() - 1);        params.put(key.toLowerCase(), value);      }      ) )    (    getParams4recursion(params)  ) ?    {    return;  }}void delete() throws StorageException :{}{  (    parseER()    {      nqlProcessor.finishERParse();    }  )  {    nqlProcessor.finishDelete();    return;  }}void select() throws StorageException :{ //  System.out.println(" select ");}{	(	  parseER()	  {	    nqlProcessor.finishERParse();	  }	)  (    filter()  )?  (    strict()  )?  (    limit()  )?  {    return;  }}/** * Entiry point for * e[...] * r[...] * e[...]/r[...]/...  * */void parseER() throws StorageException :{  //  System.out.println(" parseER ");  Network net = null;  Map<String, String> techParams = new HashMap<String, String>();  boolean optional = false;}{    (	  (	    (	      < E_LBRACE > { nqlProcessor.startERAttributeProcessing("entity"); }	    | < R_LBRACE > { nqlProcessor.startERAttributeProcessing("relation"); }	    | < F_LBRACE > { nqlProcessor.startERAttributeProcessing("filter"); }	    )		    // empty e[] or r[] mean get all	    (	      net = parseERBraceExpression()	    ) ?		    // technical parameters e.g. [type='virtual' flow='']	    (	      < LBRACE >	        getParams(techParams)	      < RBRACE >	    ) ?	    	    // close right brace	    ( < RBRACE > | < RPAREN > )	    // can be optional e.g.  e()/r()?/e() 	    (< OPTIONAL >		    {		      optional = true;		    }	    )?	    {	        nqlProcessor.finishERAttributeProcessing(net, techParams, optional);	    }	  )	  |	  (	    (	      < LBRACE >	        getParams4recursion(techParams)	      < RBRACE >	    )	    {	        nqlProcessor.recursiveERSubpath(techParams);      	    }      )          )  // check for path queries: e[...]/r[...]/...  (< SUBPATH >    {      nqlProcessor.startERSubpath();    }    // e[]/r[]/...    parseER()  )?    {    return;  }}void filter() throws StorageException :{//  System.out.println(" filter() ");}{  (< FILTER >    < LPAREN >    (      getFilterExpression()    )*    < RPAREN >    {        nqlProcessor.doFilter();    }  )  {    return;  }}void getFilterExpression() throws StorageException :{//  System.out.println(" getFilterExpression() ");  Token tFilterSize, tKey, tValue;  String erType, sKey, sValue, filterSize;}{  (    (      < E_LBRACE >      {        erType = "entity";      }    | < R_LBRACE >      {        erType = "relation";      }    )    (      (      tKey = < STRING >        {}      )      (< EQUALS >)      (//        tValue = < STRING >//        {//          sValue = tValue.image;//        }//      |        tValue = < QUOTED_STRING >        { // need to get rid of quotes.          sValue = tValue.image.substring(1, tValue.image.length() - 1);        }      )      {        sKey = tKey.image;      }    )        ( < RBRACE > | < RPAREN > )	  (	    tFilterSize = < DIGIT >	  | tFilterSize = < NUMBER >	  )    {      filterSize = tFilterSize.image;      nqlProcessor.addFilter(erType, sKey, sValue, Integer.parseInt(filterSize));    }  )  (    < COMMA >    getFilterExpression()  )?  {    return;  }}/*void expand() throws StorageException :{  Token tExpandLevel;  int expandLevel = 1;}{  (< EXPAND >  {}  (    tExpandLevel = < DIGIT >  | tExpandLevel = < NUMBER >  )  {    expandLevel = Integer.parseInt(tExpandLevel.image);    nqlProcessor.setExpandLevel(expandLevel);  }  )  (    (      expandIgnore()    )  |    (      expandUseOnly()    )  )?  {    nqlProcessor.doExpand(expandLevel);    return;  }}*/void recursionIgnore() throws StorageException :{//  System.out.println(" ignore ");}{  (    < IGNORE >     < LPAREN >    (      getIgnoreAttribute()    )*    < RPAREN >    {}  )  {    return;  }}void recursionUseOnly() throws StorageException :{//  System.out.println(" use only ");}{  (    < USE_ONLY >     < LPAREN >    (      getUseOnlyAttribute()    )*    < RPAREN >    {}  )  {    return;  }}void getUseOnlyAttribute() throws StorageException :{  Token tUseOnlyDepthLevel = null;  int useOnlyDepthLevel = -1;  Token tKey, tComparator, tValue;  String sKey, sValue;}{  (	  (	    tUseOnlyDepthLevel = < DIGIT >	  | tUseOnlyDepthLevel = < NUMBER >	  )  )?  {    if (null != tUseOnlyDepthLevel)        useOnlyDepthLevel = Integer.parseInt(tUseOnlyDepthLevel.image);  }    (    tKey = < STRING >    {}  )  (    tComparator = < EQUALS >  )  (    tValue = < QUOTED_STRING >    { // need to get rid of quotes.      sValue = tValue.image.substring(1, tValue.image.length() - 1);    }  )  {    sKey = tKey.image;    nqlProcessor.addExpandUseOnlyAttribute(useOnlyDepthLevel, sKey, sValue);    return;  }}void getIgnoreAttribute() throws StorageException :{  Token tIgnoreDepthLevel = null;  int ignoreDepthLevel = -1;  Token tKey, tComparator, tValue;  String sKey, sValue;}{  (	  (	    tIgnoreDepthLevel = < DIGIT >	  | tIgnoreDepthLevel = < NUMBER >	  )        )?  {    if (null != tIgnoreDepthLevel)        ignoreDepthLevel = Integer.parseInt(tIgnoreDepthLevel.image);  }    (    tKey = < STRING >    {}  )  (    tComparator = < EQUALS >  )  (    tValue = < QUOTED_STRING >    { // need to get rid of quotes.      sValue = tValue.image.substring(1, tValue.image.length() - 1);    }  )  {    sKey = tKey.image;    nqlProcessor.addExpandIgnoreAttribute(ignoreDepthLevel, sKey, sValue);    return;  }}Network parseERAttribute() throws StorageException :{  Token tKey, tComparator, tValue;  String sKey, sValue;  Network net;//  System.out.println(" parseERAttribute ");}{  (    tKey = < STRING >    {}  )  (    tComparator = < EQUALS >  | tComparator = < NOTEQUAL >  | tComparator = < LIKE >  )  (    tValue = < QUOTED_STRING >    { // need to get rid of quotes.
      sValue = tValue.image.substring(1, tValue.image.length() - 1);    }  )  {    sKey = tKey.image;//    System.out.println(sKey + " = " + sValue);    Map params = new HashMap();    params.put("key", sKey);    params.put("comparator", tComparator.image);    params.put("value", sValue);    Network net1 = nqlProcessor.addERAttribute(params);    return net1;  }}// (a='1' AND b='2' AND c='3')Network parseERSimpleExpression(Network inputNet) throws StorageException :{  Network net1 = inputNet;  if (null == net1)  {    net1 = new Network();  }  Network net2 = null;  String operand = null;//  Set<String> srcids = null;}{  (    operand = attributeExpressionOperand()    (	    (	      < LPAREN >	        {	            // Map params = new HashMap();	            // Network net =	            // don't use return parameter - because it isn't used in InMemoryProcessor. In SolrProcessor is used for brace generation                 // nqlProcessor.startERAttributeExpression(new HashMap());                nqlProcessor.startERAttributeExpression(null);	        }	       net2 = parseERBraceExpression()	      < RPAREN >        {            // Map params = new HashMap();            // Network net =            // don't use return parameter - because it isn't used in InMemoryProcessor. In SolrProcessor is used for brace generation             // nqlProcessor.finishERAttributeExpression(new HashMap());            nqlProcessor.finishERAttributeExpression(null);        }	    )        |        (        net2 = parseERAttribute()        )        |        (          {            Set<Path> connectedStack = nqlProcessor.getDefaultConnectedStack();          }          net2 = parseConnected(connectedStack)        )    )      )    {    Map params = new HashMap();    params.put("net1", net1);    params.put("net2", net2);    params.put("operand", operand);    Network net = nqlProcessor.doSimpleERAttributeExpression(params);    return net;  }}Network parseConnectedAttribute(Set<Path> connectedStack) throws StorageException :{  Token tKey, tComparator, tValue;  String sKey, sValue;//  Network net;//  System.out.println(" parseConnectedAttribute() ");}{  (    tKey = < STRING >  )  (    tComparator = < EQUALS >  | tComparator = < NOTEQUAL >  | tComparator = < LIKE >  )  (    tValue = < QUOTED_STRING >    { // need to get rid of quotes.      sValue = tValue.image.substring(1, tValue.image.length() - 1);    }  )  {    sKey = tKey.image;    Map params = new HashMap();    params.put("key", sKey);    params.put("comparator", tComparator.image);    params.put("value", sValue);    Network net = nqlProcessor.getConnected(connectedStack, params);    return net;  }}Network parseConnectedBraceExpression(Set<Path> connectedStack) throws StorageException :{  Network net = new Network();  boolean isEmpty = true;//  System.out.println(" parseConnectedBraceExpression() ");}{  (      (        < LPAREN >         net = parseConnectedBraceExpression(connectedStack)        < RPAREN >      )    |    (      net = parseConnectedAttribute(connectedStack)    )    {      isEmpty = false;      System.out.println(" parseConnectedBraceExpression() - > not empty ");    }  )?  {    if (isEmpty)    {      // e.g. select e[connected()]  - > should return entities which have relations ?    }  }  (    // (a='1' AND b='2' AND c='3')        net = parseConnectedSimpleExpression(connectedStack, net)  )*    {    return net;  }}Network parseConnectedSimpleExpression(Set<Path> connectedStack, Network inputNet) throws StorageException :{  Network net1 = inputNet;  if (null == net1)  {    net1 = new Network();  }  Network net2 = null;  String operand = null;}{  (    operand = attributeExpressionOperand()    (        (          < LPAREN >           net2 = parseConnectedBraceExpression(connectedStack)          < RPAREN >        )        |        (        net2 = parseConnectedAttribute(connectedStack)        )        |        (          // recalculate connectedStack          {            nqlProcessor.updateConnectedStack(connectedStack, net1);          }          net2 = parseConnected(connectedStack)        )    )      )    {    Map params = new HashMap();    params.put("net1", net1);    params.put("net2", net2);    params.put("operand", operand);    Network net = nqlProcessor.doSimpleERAttributeExpression(params);    return net;  }}Network parseConnected(Set<Path> connectedStack) throws StorageException :{  Network connectedNet = null;//  Network net = null;//  System.out.println(" parseConnected() ");}{  (    < CONNECTED >  )  (    < LPAREN >       connectedNet = parseConnectedBraceExpression(connectedStack)    < RPAREN >  )  {    Network net = nqlProcessor.finishGetConnected(connectedStack, connectedNet);    return net;  }}// AND | ORString attributeExpressionOperand() throws StorageException :{  String operand = null;}{    (      < AND >      {        nqlProcessor.addERAttributeExpression("AND");        operand = "AND";      }    | < OR >      {        nqlProcessor.addERAttributeExpression("OR");        operand = "OR";      }    )  {    return operand;  }}Network parseERBraceExpression() throws StorageException :{  Network net1 = null;//  Set<String> srcids = null;  //  System.out.println(" parseERBraceExpression ");}{  (      (        < LPAREN >        {            // Map params = new HashMap();            // Network net =            // don't use return parameter - because it isn't used in InMemoryProcessor. In SolrProcessor is used for brace generation             // nqlProcessor.startERAttributeExpression(new HashMap());            nqlProcessor.startERAttributeExpression(null);        }         net1 = parseERBraceExpression()        < RPAREN >	    {	        // Map params = new HashMap();            // Network net =            // don't use return parameter - because it isn't used in InMemoryProcessor. In SolrProcessor is used for brace generation             // nqlProcessor.finishERAttributeExpression(new HashMap());            nqlProcessor.finishERAttributeExpression(null);	    }      )    |    (      net1 = parseERAttribute()    )    |    (      {            Set<Path> connectedStack = nqlProcessor.getDefaultConnectedStack();      }      net1 = parseConnected(connectedStack)    )  )  (    // (a='1' AND b='2' AND c='3')        net1 = parseERSimpleExpression(net1)  )*  
  {    return net1;  }}void strict() throws StorageException :{//  System.out.println(" strict() ");}{    < STRICT >    {        nqlProcessor.setStrict(true);    }  {    return;  }}void limit() throws StorageException :{//  System.out.println(" strict() ");  Token tMaxNetworkSize;}{    < LIMIT >  (    tMaxNetworkSize = < DIGIT >  | tMaxNetworkSize = < NUMBER >  )    {        nqlProcessor.setMaxOutputNetworkSize(Long.parseLong(tMaxNetworkSize.image));    }  {    return;  }}/**  And now, the actual parsing specifications...... *//** Skip these characters, they are considered "white space" **/SKIP :{  " "| "\t"| "\r"| "\n"}TOKEN :{  < #LETTER : [     "a"-"z",     "A"-"Z",     "\u00aa",     "\u00b5",     "\u00ba",     "\u00c0"-"\u00d6",     "\u00d8"-"\u00f6",     "\u00f8"-"\u01f5",     "\u01fa"-"\u0217",     "\u0250"-"\u02a8",     "\u02b0"-"\u02b8",     "\u02bb"-"\u02c1",     "\u02d0"-"\u02d1",     "\u02e0"-"\u02e4",     "\u037a",     "\u0386",     "\u0388"-"\u038a",     "\u038c",     "\u038e"-"\u03a1",     "\u03a3"-"\u03ce",     "\u03d0"-"\u03d6",     "\u03da",     "\u03dc",     "\u03de",     "\u03e0",     "\u03e2"-"\u03f3",     "\u0401"-"\u040c",     "\u040e"-"\u044f",     "\u0451"-"\u045c",     "\u045e"-"\u0481",     "\u0490"-"\u04c4",     "\u04c7"-"\u04c8",     "\u04cb"-"\u04cc",     "\u04d0"-"\u04eb",     "\u04ee"-"\u04f5",     "\u04f8"-"\u04f9",     "\u0531"-"\u0556",     "\u0559",     "\u0561"-"\u0587",     "\u05d0"-"\u05ea",     "\u05f0"-"\u05f2",     "\u0621"-"\u063a",     "\u0640"-"\u064a",     "\u0671"-"\u06b7",     "\u06ba"-"\u06be",     "\u06c0"-"\u06ce",     "\u06d0"-"\u06d3",     "\u06d5",     "\u06e5"-"\u06e6",     "\u0905"-"\u0939",     "\u093d",     "\u0958"-"\u0961",     "\u0985"-"\u098c",     "\u098f"-"\u0990",     "\u0993"-"\u09a8",     "\u09aa"-"\u09b0",     "\u09b2",     "\u09b6"-"\u09b9",     "\u09dc"-"\u09dd",     "\u09df"-"\u09e1",     "\u09f0"-"\u09f1",     "\u0a05"-"\u0a0a",     "\u0a0f"-"\u0a10",     "\u0a13"-"\u0a28",     "\u0a2a"-"\u0a30",     "\u0a32"-"\u0a33",     "\u0a35"-"\u0a36",     "\u0a38"-"\u0a39",     "\u0a59"-"\u0a5c",     "\u0a5e",     "\u0a72"-"\u0a74",     "\u0a85"-"\u0a8b",     "\u0a8d",     "\u0a8f"-"\u0a91",     "\u0a93"-"\u0aa8",     "\u0aaa"-"\u0ab0",     "\u0ab2"-"\u0ab3",     "\u0ab5"-"\u0ab9",     "\u0abd",     "\u0ae0",     "\u0b05"-"\u0b0c",     "\u0b0f"-"\u0b10",     "\u0b13"-"\u0b28",     "\u0b2a"-"\u0b30",     "\u0b32"-"\u0b33",     "\u0b36"-"\u0b39",     "\u0b3d",     "\u0b5c"-"\u0b5d",     "\u0b5f"-"\u0b61",     "\u0b85"-"\u0b8a",     "\u0b8e"-"\u0b90",     "\u0b92"-"\u0b95",     "\u0b99"-"\u0b9a",     "\u0b9c",     "\u0b9e"-"\u0b9f",     "\u0ba3"-"\u0ba4",     "\u0ba8"-"\u0baa",     "\u0bae"-"\u0bb5",     "\u0bb7"-"\u0bb9",     "\u0c05"-"\u0c0c",     "\u0c0e"-"\u0c10",     "\u0c12"-"\u0c28",     "\u0c2a"-"\u0c33",     "\u0c35"-"\u0c39",     "\u0c60"-"\u0c61",     "\u0c85"-"\u0c8c",     "\u0c8e"-"\u0c90",     "\u0c92"-"\u0ca8",     "\u0caa"-"\u0cb3",     "\u0cb5"-"\u0cb9",     "\u0cde",     "\u0ce0"-"\u0ce1",     "\u0d05"-"\u0d0c",     "\u0d0e"-"\u0d10",     "\u0d12"-"\u0d28",     "\u0d2a"-"\u0d39",     "\u0d60"-"\u0d61",     "\u0e01"-"\u0e2e",     "\u0e30",     "\u0e32"-"\u0e33",     "\u0e40"-"\u0e46",     "\u0e81"-"\u0e82",     "\u0e84",     "\u0e87"-"\u0e88",     "\u0e8a",     "\u0e8d",     "\u0e94"-"\u0e97",     "\u0e99"-"\u0e9f",     "\u0ea1"-"\u0ea3",     "\u0ea5",     "\u0ea7",     "\u0eaa"-"\u0eab",     "\u0ead"-"\u0eae",     "\u0eb0",     "\u0eb2"-"\u0eb3",     "\u0ebd",     "\u0ec0"-"\u0ec4",     "\u0ec6",     "\u0edc"-"\u0edd",     "\u0f40"-"\u0f47",     "\u0f49"-"\u0f69",     "\u10a0"-"\u10c5",     "\u10d0"-"\u10f6",     "\u1100"-"\u1159",     "\u115f"-"\u11a2",     "\u11a8"-"\u11f9",     "\u1e00"-"\u1e9b",     "\u1ea0"-"\u1ef9",     "\u1f00"-"\u1f15",     "\u1f18"-"\u1f1d",     "\u1f20"-"\u1f45",     "\u1f48"-"\u1f4d",     "\u1f50"-"\u1f57",     "\u1f59",     "\u1f5b",     "\u1f5d",     "\u1f5f"-"\u1f7d",     "\u1f80"-"\u1fb4",     "\u1fb6"-"\u1fbc",     "\u1fbe",     "\u1fc2"-"\u1fc4",     "\u1fc6"-"\u1fcc",     "\u1fd0"-"\u1fd3",     "\u1fd6"-"\u1fdb",     "\u1fe0"-"\u1fec",     "\u1ff2"-"\u1ff4",     "\u1ff6"-"\u1ffc",     "\u207f",     "\u2102",     "\u2107",     "\u210a"-"\u2113",     "\u2115",     "\u2118"-"\u211d",     "\u2124",     "\u2126",     "\u2128",     "\u212a"-"\u2131",     "\u2133"-"\u2138",     "\u3005",     "\u3031"-"\u3035",     "\u3041"-"\u3094",     "\u309b"-"\u309e",     "\u30a1"-"\u30fa",     "\u30fc"-"\u30fe",     "\u3105"-"\u312c",     "\u3131"-"\u318e",     "\u4e00"-"\u9fa5",     "\uac00"-"\ud7a3",     "\uf900"-"\ufa2d",     "\ufb00"-"\ufb06",     "\ufb13"-"\ufb17",     "\ufb1f"-"\ufb28",     "\ufb2a"-"\ufb36",     "\ufb38"-"\ufb3c",     "\ufb3e",     "\ufb40"-"\ufb41",     "\ufb43"-"\ufb44",     "\ufb46"-"\ufbb1",     "\ufbd3"-"\ufd3d",     "\ufd50"-"\ufd8f",     "\ufd92"-"\ufdc7",     "\ufdf0"-"\ufdfb",     "\ufe70"-"\ufe72",     "\ufe74",     "\ufe76"-"\ufefc",     "\uff21"-"\uff3a",     "\uff41"-"\uff5a",     "\uff66"-"\uffbe",     "\uffc2"-"\uffc7",     "\uffca"-"\uffcf",     "\uffd2"-"\uffd7",     "\uffda"-"\uffdc"     ] >}TOKEN :{ < DIGIT : [     "0"-"9",     "\u0660"-"\u0669",     "\u06f0"-"\u06f9",     "\u0966"-"\u096f",     "\u09e6"-"\u09ef",     "\u0a66"-"\u0a6f",     "\u0ae6"-"\u0aef",     "\u0b66"-"\u0b6f",     "\u0be7"-"\u0bef",     "\u0c66"-"\u0c6f",     "\u0ce6"-"\u0cef",     "\u0d66"-"\u0d6f",     "\u0e50"-"\u0e59",     "\u0ed0"-"\u0ed9",     "\u0f20"-"\u0f29",     "\uff10"-"\uff19"     ] >}TOKEN : {  < NUMBER :    (    < DIGIT >    )* >}TOKEN : /*RESERVED TOKENS FOR NQL */{  < PIPE :    "|"  | "USE FOR" >| < AND :    "and"  | "AND" >| < SQL :    "sql"  | "SQL" >| < SELECT :    "select"  | "SELECT" >| < DELETE :    "delete"  | "DELETE" >| < INSERT :    "insert"  | "INSERT" >| < UPDATE :    "update"  | "UPDATE" >  | < SET_PROPERTY :    "+"  |  "set"  | "SET" >| < REMOVE_PROPERTY :    "-"  |  "remove"  | "REMOVE" >| < WHERE :    "where"  | "WHERE" >| < BEHAVE :    "behave"  | "BEHAVE" >| < IGNORE :    "IGNORE"  | "ignore" >| < USE_ONLY :    "USEONLY"  | "useonly" >| < FILTER :    "FILTER"  | "filter" >| < LIMIT :    "LIMIT"  | "limit" >| < STRICT :    "STRICT"  | "strict" >| < PATH :    "PATH"  | "path" >| < LIST :    "LIST"  | "list" >| < OPTIONAL :    "?" >| < E_LBRACE :    "E[" |    "e[" |    "E(" |    "e(" >| < R_LBRACE :    "R[" |    "r[" |    "R(" |    "r(" >| < F_LBRACE :    "F[" |    "f[" |    "F(" |    "f(" >| < LBRACE : "[" >| < RBRACE : "]" >| < SUBPATH : "/" >| < OR :    "or"  | "OR" >| < LPAREN : "(" >| < RPAREN : ")" >| < LIKE :        "like" |        "LIKE" >| < NOTEQUAL : "!=" >| < EQUALS : "=" >| < COMMA : "," >| < CONNECTED :    "CONNECTED"  | "connected" >}TOKEN : /* the keywords and comparators - QUOTEDVALUE accounts for escaped quotes as well  */{  < STRING :    (      < LETTER >    | "."    | "-"    | "_"    | < DIGIT >    )* >| < QUOTED_STRING :    (      (        "\'" (~[ "\'" ])+ "\'"      )    |      (        "\"" (~[ "\"" ])+ "\""      )    ) >}
